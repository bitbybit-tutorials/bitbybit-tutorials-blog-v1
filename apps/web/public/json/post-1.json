{
  "abstract": "In this post we'll explore how we can create a smooth, responsive and intuitive swipe to delete in React Native and what challenges and limitations we might face.",
  "category": [
    "JavaScript",
    "React",
    "React Native"
  ],
  "created": "01-12-2021",
  "id": 1,
  "isPublished": true,
  "image": "test.png",
  "lastUpdated": "02-12-2021",
  "seoTitle": "Something more descriptive",
  "title": "Implementing a WhatsApp like Swipe to Delete Feature in ReactÂ Native",
  "type": "post",
  "updates": [
    {
      "year": "02-12-2021",
      "note": "We updated this and that"
    }
  ],
  "slug": "post-1",
  "compiledSource": {
    "compiledSource": "var h=Object.defineProperty,c=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var l=(e,t,i)=>t in e?h(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,a=(e,t)=>{for(var i in t||(t={}))r.call(t,i)&&l(e,i,t[i]);if(o)for(var i of o(t))s.call(t,i)&&l(e,i,t[i]);return e},d=(e,t)=>c(e,m(t));var p=(e,t)=>{var i={};for(var n in e)r.call(e,n)&&t.indexOf(n)<0&&(i[n]=e[n]);if(e!=null&&o)for(var n of o(e))t.indexOf(n)<0&&s.call(e,n)&&(i[n]=e[n]);return i};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(i){var n=i,{components:e}=n,t=p(n,[\"components\"]);return mdx(MDXLayout,d(a(a({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Swipe to delete has become a very common feature present in most mobile apps\ntoday. If done correctly, it feels like all's right with the world. If not, it\ncan turn into a nightmarish experience for the user resulting in countless\nrecipes and playlist songs unexpectedly disappearing into the ether.`),mdx(\"h2\",null,\"Goal\"),mdx(\"p\",null,\"In this post we'll explore how we can create a smooth, responsive and intuitive swipe to delete in React Native and what challenges and limitations we might face. I am a big fan of the WhatsApp implementation so we'll aim for a similar look and feel.\"),mdx(\"h2\",null,\"Objectives\"),mdx(\"p\",null,\"In order to deliver on our promise, here's some of the criteria our design needs to meet:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Provide visual and sensory cues to signal to users what action is taking place and what the consequences of following through on that action will be\"),mdx(\"li\",{parentName:\"ul\"},\"Allow users to change their mind mid swipe and cancel the action\"),mdx(\"li\",{parentName:\"ul\"},\"Provide feedback after a swipe has been completed\"),mdx(\"li\",{parentName:\"ul\"},\"Achieve smooth and seamless transitions and animations to deliver a great user experience\")),mdx(\"p\",null,\"Here is what our end product will look like:\"),mdx(\"iframe\",{className:\"youtube-iframe\",src:\"https://www.youtube.com/embed/toYJtzowkU8\",frameBorder:\"0\",allowFullScreen:!0}),mdx(\"h2\",null,\"Implementation\"),mdx(\"p\",null,\"We'll be using a third-party library called \",mdx(\"a\",a({parentName:\"p\"},{href:\"https://github.com/jemise111/react-native-swipe-list-view\"}),\"react-native-swipe-list-view\"),\" which gives us a Swipe List component in conjunction with React Native's \",mdx(\"a\",a({parentName:\"p\"},{href:\"https://reactnative.dev/docs/animated\"}),\"Animated API\"),\" for more granular control over our animations.\"),mdx(\"p\",null,\"You can find the complete example on \",mdx(\"a\",a({parentName:\"p\"},{href:\"https://github.com/bitbybit-tutorials/react-native-swipe-to-delete\"}),\"Github\"),\".\"),mdx(\"p\",null,\"If you prefer a longer video format check out this video:\"),mdx(\"iframe\",{className:\"youtube-iframe\",src:\"https://www.youtube.com/embed/1y_B4tBezQQ\",frameBorder:\"0\",allowFullScreen:!0}),mdx(\"p\",null,\"Let's create a new React Native project and install the library.\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-js\",metastring:\"command-line\",\"command-line\":!0}),`npx react-native init swipeToDelete\ncd swipeToDelete\nnpx react-native run-ios\n\nnpm i react-native-swipe-list-view\nnpx pod-install\n`)),mdx(\"p\",null,\"We'll import our \",mdx(\"inlineCode\",{parentName:\"p\"},\"<SwipeListView />\"),\" component and generate some dummy list data to pass to the data prop. The view also requires a \",mdx(\"inlineCode\",{parentName:\"p\"},\"renderItem\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"renderHiddenItem\"),\" props to render a front row and a hidden row which is revealed when the user swipes and contains our action buttons. We'll pass a function to each prop which accepts 2 parameters - \",mdx(\"inlineCode\",{parentName:\"p\"},\"rowData\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"rowMap\"),\" and returns a React element. \",mdx(\"inlineCode\",{parentName:\"p\"},\"rowData\"),\" as the name suggests is the extracted data for an individual row from the data array we passed earlier where as \",mdx(\"inlineCode\",{parentName:\"p\"},\"rowMap\"),\" is an object that looks like this\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`{\n  row_key_1: ref_to_row_1,\n  row_key_2: ref_to_row_2\n}\n`)),mdx(\"p\",null,\"and contains a reference to the row which can be used to access helpful methods like \",mdx(\"inlineCode\",{parentName:\"p\"},\"closeRow\"),\" to swipe a row closed programatically. The row key is the same key we are passing through our data array or if one is not defined, it will use the key generated by the \",mdx(\"inlineCode\",{parentName:\"p\"},\"keyExtractor\"),\" prop.\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-js\",metastring:\"App.js\",\"App.js\":!0}),`import React, { useState } from \"react\";\nimport { SafeAreaView, StyleSheet } from \"react-native\";\nimport { SwipeListView } from \"react-native-swipe-list-view\";\n\nconst COLORS = {\n  red: \"#cc0000\",\n  green: \"#4cA64c\",\n  blue: \"#4c4cff\",\n  white: \"#fff\",\n  grey: \"#ddd\",\n};\n\nconst App = () => {\n  const [list, setList] = useState(\n    [...new Array(20)].map((_, i) => ({\n      key: \\`\\${i}\\`,\n      text: \\`This is list item \\${i}\\`,\n    }))\n  );\n\n  const renderItem = (rowData, rowMap) => (\n    <VisibleItem rowData={rowData} rowMap={rowMap} />\n  );\n\n  const renderHiddenItem = (rowData, rowMap) => (\n    <HiddenItemWithActions rowData={rowData} rowMap={rowMap} />\n  );\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <SwipeListView\n        data={list}\n        renderItem={renderItem}\n        renderHiddenItem={renderHiddenItem}\n        disableRightSwipe\n        rightOpenValue={-120}\n      />\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    backgroundColor: COLORS.white,\n  },\n});\n\nexport default App;\n`)),mdx(\"p\",null,\"We are also adding the \",mdx(\"inlineCode\",{parentName:\"p\"},\"disableRightSwipe\"),\" prop to disable swiping from left to right for simplicity sake and setting the \",mdx(\"inlineCode\",{parentName:\"p\"},\"rightOpenValue\"),\" prop to -120 which is the translate value for the front row along the x-axis when the row is opened. The value will always be negative since we want to shift the front row to the left to reveal the hidden row on the right side.\"),mdx(\"p\",null,\"Next, we'll add the \",mdx(\"inlineCode\",{parentName:\"p\"},\"<VisibleItem />\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"<HiddenItemWithActions />\"),\" components which are returned from the \",mdx(\"inlineCode\",{parentName:\"p\"},\"renderItem\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"renderHiddenItem\"),\" functions. They are responsible for rendering the content of the front and back row. They can also react to changes in the swipe state and show that some action has been activated, e.g. expand the delete button to full width of the row. To enable this behaviour we also need to set some props to configure these actions.\"),mdx(\"p\",null,\"We'll need some icons too.\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-js\",metastring:\"command-line\",\"command-line\":!0}),`npm i react-native-svg\nnpx pod-install\nnpm i react-native-eva-icons\n`)),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-js\",metastring:\"App.js\",\"App.js\":!0}),`// ...\nimport {\n  // ...\n  Text,\n  View,\n  TouchableWithoutFeedback,\n  useWindowDimensions,\n} from \"react-native\";\nimport { Icon } from \"react-native-eva-icons\";\n// ...\n\nconst VisibleItem = (props) => {\n  const { rowData } = props;\n\n  return (\n    <View style={[styles.rowFront, (height: 60)]}>\n      <Text>{rowData.item.text}</Text>\n    </View>\n  );\n};\n\nconst HiddenItemWithActions = (props) => {\n  const { rightActionActivated, swipeAnimatedValue, rowData } = props;\n\n  return (\n    <View style={styles.rowBack}>\n      <TouchableWithoutFeedback onPress={() => console.log(\"close row\")}>\n        <View\n          style={[\n            styles.backBtn,\n            styles.backRightBtn,\n            styles.backRightBtnLeft,\n            {\n              width: 60,\n            },\n          ]}\n        >\n          <View style={styles.backBtnInner}>\n            <Icon\n              name=\"arrow-back-outline\"\n              fill=\"#fff\"\n              width={26}\n              height={26}\n            />\n            <Text style={styles.backBtnText}>Right</Text>\n          </View>\n        </View>\n      </TouchableWithoutFeedback>\n      <TouchableWithoutFeedback onPress={() => console.log(\"delete row\")}>\n        <View\n          style={[\n            styles.backBtn,\n            styles.backRightBtn,\n            styles.backRightBtnRight,\n            {\n              width: 60,\n            },\n          ]}\n        >\n          <View style={styles.backBtnInner}>\n            <Icon name=\"trash-2-outline\" fill=\"#fff\" width={26} height={26} />\n            <Text style={styles.backBtnText}>Delete</Text>\n          </View>\n        </View>\n      </TouchableWithoutFeedback>\n    </View>\n  );\n};\n\nconst App = () => {\n  // ...\n  const { width: screenWidth } = useWindowDimensions();\n\n  const onRightActionStatusChange = (rowKey) => {\n    console.log(\"on right action status change\");\n  };\n\n  const swipeGestureEnded = (rowKey, data) => {\n    console.log(\"on swipe gesture ended\");\n  };\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <SwipeListView\n        data={list}\n        renderItem={renderItem}\n        renderHiddenItem={renderHiddenItem}\n        disableRightSwipe\n        rightOpenValue={-120}\n        stopRightSwipe={-201}\n        rightActivationValue={-200}\n        rightActionValue={-screenWidth}\n        onRightActionStatusChange={onRightActionStatusChange}\n        swipeGestureEnded={swipeGestureEnded}\n        swipeToOpenPercent={10}\n        swipeToClosePercent={10}\n        useNativeDriver={false}\n      />\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  // ...\n  rowFront: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    backgroundColor: COLORS.white,\n    borderBottomColor: COLORS.grey,\n    borderBottomWidth: 1,\n  },\n  rowBack: {\n    height: 60,\n  },\n  backBtn: {\n    position: \"absolute\",\n    bottom: 0,\n    top: 0,\n    justifyContent: \"center\",\n  },\n  backRightBtn: {},\n  backRightBtnLeft: {\n    right: 60,\n    backgroundColor: COLORS.blue,\n  },\n  backRightBtnRight: {\n    right: 0,\n    backgroundColor: COLORS.red,\n  },\n  backBtnInner: {\n    alignItems: \"center\",\n  },\n  backBtnText: {\n    color: COLORS.white,\n    marginTop: 2,\n  },\n});\n`)),mdx(\"p\",null,\"We are utilising the \",mdx(\"inlineCode\",{parentName:\"p\"},\"rightActivationValue\"),\" prop as an indicator to signify to the user that an important action is able to take place should they decide to proceed. Once the swipe value exceeds the \",mdx(\"inlineCode\",{parentName:\"p\"},\"rightActivationValue\"),\" it will fire off the \",mdx(\"inlineCode\",{parentName:\"p\"},\"onRightActionStatusChange\"),\" function and activate the \",mdx(\"inlineCode\",{parentName:\"p\"},\"rightActionActivated\"),\" value which is another prop we can pass to the hidden row component and make use of to animate the delete button expanding to the full width of the row or contacting to its initial width if the action is cancelled.\"),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"swipeGestureEnded\"),\" prop takes a function which is called when the user has ended their swipe gesture and can be used to animate the row being deleted and to provide confirmation of the successful completion of the action. The \",mdx(\"inlineCode\",{parentName:\"p\"},\"rightActionValue\"),\" is the translateX value to which the row will be shifted after the gesture is released which in our case is the whole width of the screen so that the front row disappears completely. The \",mdx(\"inlineCode\",{parentName:\"p\"},\"swipeToOpenPercent / swipeToClosePercent\"),\" props are the percentage of the \",mdx(\"inlineCode\",{parentName:\"p\"},\"rightOpenValue\"),\" the user needs to swipe past to trigger the row opening / closing.\"),mdx(\"p\",null,\"We are also setting the \",mdx(\"inlineCode\",{parentName:\"p\"},\"useNativeDriver\"),\" prop to false because we'll be animating layout properties that are not supported by the native driver such as the height and width of the row.\"),mdx(\"h2\",null,\"Animations\"),mdx(\"p\",null,\"In order to animate the rows and buttons we need to do a refactor of the visible and hidden component and wrap some of the content with animatable components. We'll create a list to store the animated values for the row height and the delete button width for all rows. We'll also want to animate the translateX property of the buttons to create a smooth in and out of view transition. For that purpose we can make use of another prop passed to the hidden component called \",mdx(\"inlineCode\",{parentName:\"p\"},\"swipeAnimatedValue\"),\" which gives us direct access to the swipe row translateX animated value. We can interpolate that value to get the transition just the way we want it.\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-js\",metastring:\"App.js\",\"App.js\":!0}),`import {\n  // ...\n  Animated,\n} from \"react-native\";\n// ....\n\nconst rowAnimatedValues = {};\nArray(20)\n  .fill(\"\")\n  .forEach((_, i) => {\n    rowAnimatedValues[\\`\\${i}\\`] = {\n      rowHeight: new Animated.Value(60),\n      deleteBtnWidth: new Animated.Value(100),\n    };\n  });\n\nconst VisibleItem = (props) => {\n  // ...\n  const rowKey = rowData.item.key;\n\n  return (\n    <Animated.View\n      style={[\n        styles.rowFront,\n        {\n          height: rowAnimatedValues[rowKey].rowHeight,\n        },\n      ]}\n    >\n      <Text>{rowData.item.text}</Text>\n    </Animated.View>\n  );\n};\n\nconst HiddenItemWithActions = (props) => {\n  // ...\n  const rowKey = rowData.item.key;\n\n  if (rightActionActivated) {\n    Animated.timing(rowAnimatedValues[rowKey].deleteBtnWidth, {\n      toValue: Math.abs(swipeAnimatedValue.__getValue()),\n      duration: 250,\n      useNativeDriver: false,\n    }).start();\n  } else {\n    Animated.timing(rowAnimatedValues[rowKey].deleteBtnWidth, {\n      toValue: 100,\n      duration: 250,\n      useNativeDriver: false,\n    }).start();\n  }\n\n  return (\n    <View style={styles.rowBack}>\n      <TouchableWithoutFeedback onPress={() => console.log(\"close row\")}>\n        <Animated.View\n          style={[\n            styles.backBtn,\n            styles.backRightBtn,\n            styles.backRightBtnLeft,\n            {\n              width: 100,\n              transform: [\n                {\n                  translateX: swipeAnimatedValue.interpolate({\n                    inputRange: [-200, -120, 0],\n                    outputRange: [-100, -20, 100],\n                    extrapolate: \"clamp\",\n                  }),\n                },\n              ],\n            },\n          ]}\n        >\n          <View style={styles.backBtnInner}>\n            <Icon\n              name=\"arrow-back-outline\"\n              fill=\"#fff\"\n              width={26}\n              height={26}\n            />\n            <Text style={styles.backBtnText}>Right</Text>\n          </View>\n        </Animated.View>\n      </TouchableWithoutFeedback>\n      <TouchableWithoutFeedback onPress={() => console.log(\"delete row\")}>\n        <Animated.View\n          style={[\n            styles.backBtn,\n            styles.backRightBtn,\n            styles.backRightBtnRight,\n            {\n              width: rowAnimatedValues[rowKey].deleteBtnWidth,\n              transform: [\n                {\n                  translateX: swipeAnimatedValue.interpolate({\n                    inputRange: [-200, -120, 0],\n                    outputRange: [0, 40, 100],\n                    extrapolate: \"clamp\",\n                  }),\n                },\n              ],\n            },\n          ]}\n        >\n          <View style={styles.backBtnInner}>\n            <Icon name=\"trash-2-outline\" fill=\"#fff\" width={26} height={26} />\n            <Text style={styles.backBtnText}>Delete</Text>\n          </View>\n        </Animated.View>\n      </TouchableWithoutFeedback>\n    </View>\n  );\n};\n\nconst App = () => {\n  // ...\n  const deleteRow = (rowKey) => {\n    const newData = list.filter((item) => item.key !== rowKey);\n    setList(newData);\n  };\n\n  const swipeGestureEnded = (rowKey, data) => {\n    if (data.translateX < -200) {\n      Animated.timing(rowAnimatedValues[rowKey].deleteBtnWidth, {\n        toValue: screenWidth,\n        duration: 200,\n        useNativeDriver: false,\n      }).start();\n      Animated.timing(rowAnimatedValues[rowKey].rowHeight, {\n        toValue: 0,\n        delay: 200,\n        duration: 200,\n        useNativeDriver: false,\n      }).start(() => deleteRow(rowKey));\n    }\n  };\n  // ...\n};\n\nconst styles = StyleSheet.create({\n  // ...\n  rowBack: {\n    // ...\n    alignItems: \"center\",\n    backgroundColor: COLORS.white,\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n  },\n  // ...\n  backRightBtn: {\n    right: 0,\n    alignItems: \"flex-start\",\n    paddingLeft: 12,\n  },\n  backRightBtnLeft: {\n    backgroundColor: COLORS.blue,\n  },\n  backRightBtnRight: {\n    backgroundColor: COLORS.red,\n  },\n  // ...\n});\n`)),mdx(\"p\",null,\"When the swipe gesture is released if the translateX swipe value exceeds the \",mdx(\"inlineCode\",{parentName:\"p\"},\"rightActivationValue\"),\" (< -200) the row will be shifted to our \",mdx(\"inlineCode\",{parentName:\"p\"},\"rightActionValue\"),\" and disappear from the viewport. We'll also use the \",mdx(\"inlineCode\",{parentName:\"p\"},\"Animated.timing()\"),\" API to animate the width of the delete button to fill the screen width and the row height to 0. We'll pass a callback function to the timing method which will remove the respective item from the list immediately after the animation runs making the whole row disappear completely.\"),mdx(\"h2\",null,\"Final Touch\"),mdx(\"p\",null,\"For the cherry on top, we'll provide some haptic feedback the moment the user swipes past the activation value to drive home the message that something important is taking place.\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-js\",metastring:\"command-line\",\"command-line\":!0}),`npm i react-native-haptic-feedback\nnpx pod-install\n`)),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-js\",metastring:\"App.js\",\"App.js\":!0}),`// ...\nimport ReactNativeHapticFeedback from \"react-native-haptic-feedback\";\n\n// ...\nconst options = {\n  enableVibrateFallback: true,\n  ignoreAndroidSystemSettings: false\n};\n\n// ...\nconst HiddenItemWithActions = props => {\n  // ...\n  if (rightActionActivated) {\n    ReactNativeHapticFeedback.trigger('impactLight', hapticFeedbackOptions);\n    Animated.timing(rowAnimatedValues[rowKey].deleteBtnWidth, {\n      toValue: Math.abs(swipeAnimatedValue.__getValue()),\n      duration: 250,\n      useNativeDriver: false,\n    }).start();\n  } else {\n    Animated.timing(rowAnimatedValues[rowKey].deleteBtnWidth, {\n      toValue: 100,\n      duration: 250,\n      useNativeDriver: false,\n    }).start();\n  }\n// ...\n`)),mdx(\"h2\",null,\"Considerations\"),mdx(\"p\",null,\"While this swipe list works like a charm with small lists, it doesn't fare especially well with big ones. Here are some tips to work around this limitation:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Make sure to \",mdx(\"a\",a({parentName:\"li\"},{href:\"https://reactnative.dev/docs/optimizing-flatlist-configuration\"}),\"optimise your FlatList\"),\" which is what \",mdx(\"inlineCode\",{parentName:\"li\"},\"<SwipeListView />\"),\" uses under the hood.\"),mdx(\"li\",{parentName:\"ul\"},\"Design animations to use only non-layout properties like transform and opacity which are supported by the native driver. In our example, we could have animated the scaleY property of the row instead of the height to have it disappear.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"react-native-swipe-list-view\"),\" uses React Native's Animated library and the creator has no intention of migrating to Reanimated. Find an alternative swipe list package based on Reanimated in order to offload animation and event handling logic off of the JavaScript thread and onto the UI thread.\")),mdx(\"p\",null,\"Hope you enjoyed the read :)\"))}MDXContent.isMDXComponent=!0;\n",
    "scope": {
      "abstract": "In this post we'll explore how we can create a smooth, responsive and intuitive swipe to delete in React Native and what challenges and limitations we might face.",
      "category": [
        "JavaScript",
        "React",
        "React Native"
      ],
      "created": "01-12-2021",
      "id": 1,
      "isPublished": true,
      "image": "test.png",
      "lastUpdated": "02-12-2021",
      "seoTitle": "Something more descriptive",
      "title": "Implementing a WhatsApp like Swipe to Delete Feature in ReactÂ Native",
      "type": "post",
      "updates": [
        {
          "year": "02-12-2021",
          "note": "We updated this and that"
        }
      ]
    }
  },
  "rawSource": "\nSwipe to delete has become a very common feature present in most mobile apps\ntoday. If done correctly, it feels like all's right with the world. If not, it\ncan turn into a nightmarish experience for the user resulting in countless\nrecipes and playlist songs unexpectedly disappearing into the ether.\n\n## Goal\n\nIn this post we'll explore how we can create a smooth, responsive and intuitive swipe to delete in React Native and what challenges and limitations we might face. I am a big fan of the WhatsApp implementation so we'll aim for a similar look and feel.\n\n## Objectives\n\nIn order to deliver on our promise, here's some of the criteria our design needs to meet:\n\n- Provide visual and sensory cues to signal to users what action is taking place and what the consequences of following through on that action will be\n- Allow users to change their mind mid swipe and cancel the action\n- Provide feedback after a swipe has been completed\n- Achieve smooth and seamless transitions and animations to deliver a great user experience\n\nHere is what our end product will look like:\n\n<iframe\n  className=\"youtube-iframe\"\n  src=\"https://www.youtube.com/embed/toYJtzowkU8\"\n  frameBorder=\"0\"\n  allowFullScreen\n></iframe>\n\n## Implementation\n\nWe'll be using a third-party library called [react-native-swipe-list-view](https://github.com/jemise111/react-native-swipe-list-view) which gives us a Swipe List component in conjunction with React Native's [Animated API](https://reactnative.dev/docs/animated) for more granular control over our animations.\n\nYou can find the complete example on [Github](https://github.com/bitbybit-tutorials/react-native-swipe-to-delete).\n\nIf you prefer a longer video format check out this video:\n\n<iframe\n  className=\"youtube-iframe\"\n  src=\"https://www.youtube.com/embed/1y_B4tBezQQ\"\n  frameBorder=\"0\"\n  allowFullScreen\n></iframe>\n\nLet's create a new React Native project and install the library.\n\n```js command-line\nnpx react-native init swipeToDelete\ncd swipeToDelete\nnpx react-native run-ios\n\nnpm i react-native-swipe-list-view\nnpx pod-install\n```\n\nWe'll import our `<SwipeListView />` component and generate some dummy list data to pass to the data prop. The view also requires a `renderItem` and `renderHiddenItem` props to render a front row and a hidden row which is revealed when the user swipes and contains our action buttons. We'll pass a function to each prop which accepts 2 parameters - `rowData` and `rowMap` and returns a React element. `rowData` as the name suggests is the extracted data for an individual row from the data array we passed earlier where as `rowMap` is an object that looks like this\n\n```\n{\n  row_key_1: ref_to_row_1,\n  row_key_2: ref_to_row_2\n}\n```\n\nand contains a reference to the row which can be used to access helpful methods like `closeRow` to swipe a row closed programatically. The row key is the same key we are passing through our data array or if one is not defined, it will use the key generated by the `keyExtractor` prop.\n\n```js App.js\nimport React, { useState } from \"react\";\nimport { SafeAreaView, StyleSheet } from \"react-native\";\nimport { SwipeListView } from \"react-native-swipe-list-view\";\n\nconst COLORS = {\n  red: \"#cc0000\",\n  green: \"#4cA64c\",\n  blue: \"#4c4cff\",\n  white: \"#fff\",\n  grey: \"#ddd\",\n};\n\nconst App = () => {\n  const [list, setList] = useState(\n    [...new Array(20)].map((_, i) => ({\n      key: `${i}`,\n      text: `This is list item ${i}`,\n    }))\n  );\n\n  const renderItem = (rowData, rowMap) => (\n    <VisibleItem rowData={rowData} rowMap={rowMap} />\n  );\n\n  const renderHiddenItem = (rowData, rowMap) => (\n    <HiddenItemWithActions rowData={rowData} rowMap={rowMap} />\n  );\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <SwipeListView\n        data={list}\n        renderItem={renderItem}\n        renderHiddenItem={renderHiddenItem}\n        disableRightSwipe\n        rightOpenValue={-120}\n      />\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    backgroundColor: COLORS.white,\n  },\n});\n\nexport default App;\n```\n\nWe are also adding the `disableRightSwipe` prop to disable swiping from left to right for simplicity sake and setting the `rightOpenValue` prop to -120 which is the translate value for the front row along the x-axis when the row is opened. The value will always be negative since we want to shift the front row to the left to reveal the hidden row on the right side.\n\nNext, we'll add the `<VisibleItem />` and `<HiddenItemWithActions />` components which are returned from the `renderItem` and `renderHiddenItem` functions. They are responsible for rendering the content of the front and back row. They can also react to changes in the swipe state and show that some action has been activated, e.g. expand the delete button to full width of the row. To enable this behaviour we also need to set some props to configure these actions.\n\nWe'll need some icons too.\n\n```js command-line\nnpm i react-native-svg\nnpx pod-install\nnpm i react-native-eva-icons\n```\n\n```js App.js\n// ...\nimport {\n  // ...\n  Text,\n  View,\n  TouchableWithoutFeedback,\n  useWindowDimensions,\n} from \"react-native\";\nimport { Icon } from \"react-native-eva-icons\";\n// ...\n\nconst VisibleItem = (props) => {\n  const { rowData } = props;\n\n  return (\n    <View style={[styles.rowFront, (height: 60)]}>\n      <Text>{rowData.item.text}</Text>\n    </View>\n  );\n};\n\nconst HiddenItemWithActions = (props) => {\n  const { rightActionActivated, swipeAnimatedValue, rowData } = props;\n\n  return (\n    <View style={styles.rowBack}>\n      <TouchableWithoutFeedback onPress={() => console.log(\"close row\")}>\n        <View\n          style={[\n            styles.backBtn,\n            styles.backRightBtn,\n            styles.backRightBtnLeft,\n            {\n              width: 60,\n            },\n          ]}\n        >\n          <View style={styles.backBtnInner}>\n            <Icon\n              name=\"arrow-back-outline\"\n              fill=\"#fff\"\n              width={26}\n              height={26}\n            />\n            <Text style={styles.backBtnText}>Right</Text>\n          </View>\n        </View>\n      </TouchableWithoutFeedback>\n      <TouchableWithoutFeedback onPress={() => console.log(\"delete row\")}>\n        <View\n          style={[\n            styles.backBtn,\n            styles.backRightBtn,\n            styles.backRightBtnRight,\n            {\n              width: 60,\n            },\n          ]}\n        >\n          <View style={styles.backBtnInner}>\n            <Icon name=\"trash-2-outline\" fill=\"#fff\" width={26} height={26} />\n            <Text style={styles.backBtnText}>Delete</Text>\n          </View>\n        </View>\n      </TouchableWithoutFeedback>\n    </View>\n  );\n};\n\nconst App = () => {\n  // ...\n  const { width: screenWidth } = useWindowDimensions();\n\n  const onRightActionStatusChange = (rowKey) => {\n    console.log(\"on right action status change\");\n  };\n\n  const swipeGestureEnded = (rowKey, data) => {\n    console.log(\"on swipe gesture ended\");\n  };\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <SwipeListView\n        data={list}\n        renderItem={renderItem}\n        renderHiddenItem={renderHiddenItem}\n        disableRightSwipe\n        rightOpenValue={-120}\n        stopRightSwipe={-201}\n        rightActivationValue={-200}\n        rightActionValue={-screenWidth}\n        onRightActionStatusChange={onRightActionStatusChange}\n        swipeGestureEnded={swipeGestureEnded}\n        swipeToOpenPercent={10}\n        swipeToClosePercent={10}\n        useNativeDriver={false}\n      />\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  // ...\n  rowFront: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    backgroundColor: COLORS.white,\n    borderBottomColor: COLORS.grey,\n    borderBottomWidth: 1,\n  },\n  rowBack: {\n    height: 60,\n  },\n  backBtn: {\n    position: \"absolute\",\n    bottom: 0,\n    top: 0,\n    justifyContent: \"center\",\n  },\n  backRightBtn: {},\n  backRightBtnLeft: {\n    right: 60,\n    backgroundColor: COLORS.blue,\n  },\n  backRightBtnRight: {\n    right: 0,\n    backgroundColor: COLORS.red,\n  },\n  backBtnInner: {\n    alignItems: \"center\",\n  },\n  backBtnText: {\n    color: COLORS.white,\n    marginTop: 2,\n  },\n});\n```\n\nWe are utilising the `rightActivationValue` prop as an indicator to signify to the user that an important action is able to take place should they decide to proceed. Once the swipe value exceeds the `rightActivationValue` it will fire off the `onRightActionStatusChange` function and activate the `rightActionActivated` value which is another prop we can pass to the hidden row component and make use of to animate the delete button expanding to the full width of the row or contacting to its initial width if the action is cancelled.\n\nThe `swipeGestureEnded` prop takes a function which is called when the user has ended their swipe gesture and can be used to animate the row being deleted and to provide confirmation of the successful completion of the action. The `rightActionValue` is the translateX value to which the row will be shifted after the gesture is released which in our case is the whole width of the screen so that the front row disappears completely. The `swipeToOpenPercent / swipeToClosePercent` props are the percentage of the `rightOpenValue` the user needs to swipe past to trigger the row opening / closing.\n\nWe are also setting the `useNativeDriver` prop to false because we'll be animating layout properties that are not supported by the native driver such as the height and width of the row.\n\n## Animations\n\nIn order to animate the rows and buttons we need to do a refactor of the visible and hidden component and wrap some of the content with animatable components. We'll create a list to store the animated values for the row height and the delete button width for all rows. We'll also want to animate the translateX property of the buttons to create a smooth in and out of view transition. For that purpose we can make use of another prop passed to the hidden component called `swipeAnimatedValue` which gives us direct access to the swipe row translateX animated value. We can interpolate that value to get the transition just the way we want it.\n\n```js App.js\nimport {\n  // ...\n  Animated,\n} from \"react-native\";\n// ....\n\nconst rowAnimatedValues = {};\nArray(20)\n  .fill(\"\")\n  .forEach((_, i) => {\n    rowAnimatedValues[`${i}`] = {\n      rowHeight: new Animated.Value(60),\n      deleteBtnWidth: new Animated.Value(100),\n    };\n  });\n\nconst VisibleItem = (props) => {\n  // ...\n  const rowKey = rowData.item.key;\n\n  return (\n    <Animated.View\n      style={[\n        styles.rowFront,\n        {\n          height: rowAnimatedValues[rowKey].rowHeight,\n        },\n      ]}\n    >\n      <Text>{rowData.item.text}</Text>\n    </Animated.View>\n  );\n};\n\nconst HiddenItemWithActions = (props) => {\n  // ...\n  const rowKey = rowData.item.key;\n\n  if (rightActionActivated) {\n    Animated.timing(rowAnimatedValues[rowKey].deleteBtnWidth, {\n      toValue: Math.abs(swipeAnimatedValue.__getValue()),\n      duration: 250,\n      useNativeDriver: false,\n    }).start();\n  } else {\n    Animated.timing(rowAnimatedValues[rowKey].deleteBtnWidth, {\n      toValue: 100,\n      duration: 250,\n      useNativeDriver: false,\n    }).start();\n  }\n\n  return (\n    <View style={styles.rowBack}>\n      <TouchableWithoutFeedback onPress={() => console.log(\"close row\")}>\n        <Animated.View\n          style={[\n            styles.backBtn,\n            styles.backRightBtn,\n            styles.backRightBtnLeft,\n            {\n              width: 100,\n              transform: [\n                {\n                  translateX: swipeAnimatedValue.interpolate({\n                    inputRange: [-200, -120, 0],\n                    outputRange: [-100, -20, 100],\n                    extrapolate: \"clamp\",\n                  }),\n                },\n              ],\n            },\n          ]}\n        >\n          <View style={styles.backBtnInner}>\n            <Icon\n              name=\"arrow-back-outline\"\n              fill=\"#fff\"\n              width={26}\n              height={26}\n            />\n            <Text style={styles.backBtnText}>Right</Text>\n          </View>\n        </Animated.View>\n      </TouchableWithoutFeedback>\n      <TouchableWithoutFeedback onPress={() => console.log(\"delete row\")}>\n        <Animated.View\n          style={[\n            styles.backBtn,\n            styles.backRightBtn,\n            styles.backRightBtnRight,\n            {\n              width: rowAnimatedValues[rowKey].deleteBtnWidth,\n              transform: [\n                {\n                  translateX: swipeAnimatedValue.interpolate({\n                    inputRange: [-200, -120, 0],\n                    outputRange: [0, 40, 100],\n                    extrapolate: \"clamp\",\n                  }),\n                },\n              ],\n            },\n          ]}\n        >\n          <View style={styles.backBtnInner}>\n            <Icon name=\"trash-2-outline\" fill=\"#fff\" width={26} height={26} />\n            <Text style={styles.backBtnText}>Delete</Text>\n          </View>\n        </Animated.View>\n      </TouchableWithoutFeedback>\n    </View>\n  );\n};\n\nconst App = () => {\n  // ...\n  const deleteRow = (rowKey) => {\n    const newData = list.filter((item) => item.key !== rowKey);\n    setList(newData);\n  };\n\n  const swipeGestureEnded = (rowKey, data) => {\n    if (data.translateX < -200) {\n      Animated.timing(rowAnimatedValues[rowKey].deleteBtnWidth, {\n        toValue: screenWidth,\n        duration: 200,\n        useNativeDriver: false,\n      }).start();\n      Animated.timing(rowAnimatedValues[rowKey].rowHeight, {\n        toValue: 0,\n        delay: 200,\n        duration: 200,\n        useNativeDriver: false,\n      }).start(() => deleteRow(rowKey));\n    }\n  };\n  // ...\n};\n\nconst styles = StyleSheet.create({\n  // ...\n  rowBack: {\n    // ...\n    alignItems: \"center\",\n    backgroundColor: COLORS.white,\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n  },\n  // ...\n  backRightBtn: {\n    right: 0,\n    alignItems: \"flex-start\",\n    paddingLeft: 12,\n  },\n  backRightBtnLeft: {\n    backgroundColor: COLORS.blue,\n  },\n  backRightBtnRight: {\n    backgroundColor: COLORS.red,\n  },\n  // ...\n});\n```\n\nWhen the swipe gesture is released if the translateX swipe value exceeds the `rightActivationValue` (< -200) the row will be shifted to our `rightActionValue` and disappear from the viewport. We'll also use the `Animated.timing()` API to animate the width of the delete button to fill the screen width and the row height to 0. We'll pass a callback function to the timing method which will remove the respective item from the list immediately after the animation runs making the whole row disappear completely.\n\n## Final Touch\n\nFor the cherry on top, we'll provide some haptic feedback the moment the user swipes past the activation value to drive home the message that something important is taking place.\n\n```js command-line\nnpm i react-native-haptic-feedback\nnpx pod-install\n```\n\n```js App.js\n// ...\nimport ReactNativeHapticFeedback from \"react-native-haptic-feedback\";\n\n// ...\nconst options = {\n  enableVibrateFallback: true,\n  ignoreAndroidSystemSettings: false\n};\n\n// ...\nconst HiddenItemWithActions = props => {\n  // ...\n  if (rightActionActivated) {\n    ReactNativeHapticFeedback.trigger('impactLight', hapticFeedbackOptions);\n    Animated.timing(rowAnimatedValues[rowKey].deleteBtnWidth, {\n      toValue: Math.abs(swipeAnimatedValue.__getValue()),\n      duration: 250,\n      useNativeDriver: false,\n    }).start();\n  } else {\n    Animated.timing(rowAnimatedValues[rowKey].deleteBtnWidth, {\n      toValue: 100,\n      duration: 250,\n      useNativeDriver: false,\n    }).start();\n  }\n// ...\n```\n\n## Considerations\n\nWhile this swipe list works like a charm with small lists, it doesn't fare especially well with big ones. Here are some tips to work around this limitation:\n\n- Make sure to [optimise your FlatList](https://reactnative.dev/docs/optimizing-flatlist-configuration) which is what `<SwipeListView />` uses under the hood.\n- Design animations to use only non-layout properties like transform and opacity which are supported by the native driver. In our example, we could have animated the scaleY property of the row instead of the height to have it disappear.\n- `react-native-swipe-list-view` uses React Native's Animated library and the creator has no intention of migrating to Reanimated. Find an alternative swipe list package based on Reanimated in order to offload animation and event handling logic off of the JavaScript thread and onto the UI thread.\n\nHope you enjoyed the read :)\n"
}